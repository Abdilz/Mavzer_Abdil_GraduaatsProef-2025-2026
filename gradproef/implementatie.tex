%%=============================================================================
%% Implementatie
%%=============================================================================

\chapter{Implementatie}%
\label{ch:implementatie}

Dit hoofdstuk beschrijft de technische implementatie van het AI-gestuurde callcenter in detail. We bespreken de systeemarchitectuur, de integratie met Twilio en OpenAI, en de werking van de verschillende componenten.

\section{Systeemarchitectuur}

Het systeem bestaat uit verschillende lagen die samenwerken om een naadloze gebruikerservaring te bieden. Figuur~\ref{fig:architectuur} toont een overzicht van de architectuur.

\begin{figure}[h]
\centering
\fbox{\parbox{0.9\textwidth}{
\centering
\textbf{Gespreksflow}\\[1em]
Patiënt belt $\rightarrow$ Twilio $\rightarrow$ ASP.NET Core API $\rightarrow$ OpenAI GPT\\[0.5em]
$\downarrow$\\[0.5em]
TurnUp API $\leftarrow$ Tool Handlers $\leftarrow$ Function Calling\\[0.5em]
$\downarrow$\\[0.5em]
TwiML Response $\rightarrow$ Twilio $\rightarrow$ Patiënt hoort antwoord
}}
\caption[Systeemarchitectuur]{Overzicht van de systeemarchitectuur en gespreksflow}
\label{fig:architectuur}
\end{figure}

\section{Twilio Controller}

De \texttt{TwilioController} is het ingangspunt voor alle Twilio webhooks~\autocite{TwilioWebhooks2024}. De belangrijkste endpoints zijn:

\begin{listing}
\begin{minted}[fontsize=\small]{csharp}
[HttpPost("incoming-call")]
public async Task<IActionResult> IncomingCall()
{
    var response = new VoiceResponse();
    response.Say("Press 1 for English. Druk 2 voor Nederlands.");
    response.Gather(numDigits: 1,
        action: new Uri("/api/twilio/language-selected", UriKind.Relative));
    return Content(response.ToString(), "application/xml");
}
\end{minted}
\caption[TwilioController]{Incoming call endpoint van de TwilioController}
\end{listing}

De \texttt{IncomingCall} methode wordt aangeroepen wanneer een patiënt belt. Er wordt een IVR-menu gegenereerd met \texttt{<Gather>} dat wacht op een toetsinvoer voor taalkeuze.

\section{OpenAI Integratie}

De communicatie met OpenAI verloopt via de \texttt{OpenAIChatService}. Deze service beheert de conversatiegeschiedenis en het function calling mechanisme.

\subsection{System Prompt}

De system prompt is cruciaal voor het gedrag van de AI-assistent. Een vereenvoudigd voorbeeld:

\begin{listing}
\begin{minted}[fontsize=\small]{csharp}
var languageInstruction = locale switch
{
    "nl-be" => "You MUST speak ONLY in Dutch.",
    "fr-fr" => "You MUST speak ONLY in French.",
    _ => "You MUST speak ONLY in English."
};
\end{minted}
\caption[System Prompt]{Taalselectie in de system prompt}
\end{listing}

De system prompt bevat strikte taalinstructies om te voorkomen dat de AI van taal wisselt. Daarnaast worden de beschikbare tools en gedragsregels (korte zinnen, één vraag tegelijk) meegegeven.

\subsection{Function Calling}

De AI-tools worden gedefinieerd als JSON Schema's die aan OpenAI worden meegegeven~\autocite{OpenAI2024}:

\begin{listing}
\begin{minted}[fontsize=\small]{csharp}
new FunctionDefinition {
    Name = "lookup_customer",
    Description = "Look up customer by phone number",
    Parameters = BinaryData.FromObjectAsJson(new {
        type = "object",
        properties = new { phoneNumber = new { type = "string" } },
        required = new[] { "phoneNumber" }
    })
};
\end{minted}
\caption[Function Definition]{Definitie van een OpenAI function}
\end{listing}

Functies worden gedefinieerd in JSON Schema formaat. OpenAI herkent automatisch wanneer een functie moet worden aangeroepen op basis van de gebruikersinput. Het systeem beschikt over vijf kerntools:
\begin{itemize}
    \item \texttt{lookup\_customer}: Patiëntgegevens en afspraken opzoeken
    \item \texttt{cancel\_appointment}: Afspraak annuleren na bevestiging
    \item \texttt{reschedule\_appointment}: Afspraak verzetten naar nieuw tijdstip
    \item \texttt{add\_to\_waitlist}: Patiënt toevoegen aan wachtlijst
    \item \texttt{transfer\_to\_practice}: Doorverbinden naar praktijk
\end{itemize}

\section{Tool Handlers}

Elke AI-tool heeft een bijbehorende handler die de business logic implementeert. Hieronder een voorbeeld van de \texttt{CancelAppointmentTool}:

\begin{listing}
\begin{minted}[fontsize=\small]{csharp}
public async Task<string> ExecuteAsync(CallContext context, JsonElement args)
{
    var appointment = context.GetSelectedAppointment();
    if (appointment == null) return "ERROR: No appointment selected";
    
    var result = await _apiService.CancelReservationAsync(
        appointment.ReservationId, context.CustomerId);
    return result.Success ? "Cancelled successfully." : result.ErrorMessage;
}
\end{minted}
\caption[Cancel Appointment Tool]{Execute-methode van de CancelAppointmentTool}
\end{listing}

Elke tool implementeert de \texttt{ITool} interface. De tool haalt de geselecteerde afspraak uit de context, roept de TurnUp API aan, en retourneert het resultaat aan OpenAI.

\section{Conversatie Context}

De \texttt{CallContext} klasse houdt alle relevante informatie bij gedurende een gesprek:

\begin{listing}
\begin{minted}[fontsize=\small]{csharp}
public class CallContext
{
    public string ConversationId { get; set; }
    public List<ChatMessage> Messages { get; set; } = new();
    public string UserLocale { get; set; }
    public CustomerInfo? Customer { get; private set; }
    public List<Appointment> Appointments { get; private set; }
}
\end{minted}
\caption[Call Context]{De CallContext klasse}
\end{listing}

De \texttt{CallContext} bewaart alle gespreksinformatie: conversatie-ID, chatgeschiedenis, taalvoorkeur en opgehaalde klantgegevens. Deze context wordt bij elke beurt aan de AI-prompt toegevoegd.

\section{TwiML Response Generatie}

Na verwerking door OpenAI wordt een TwiML response gegenereerd die Twilio instrueert wat te doen~\autocite{TwilioTwiML2024}:

\begin{listing}
\begin{minted}[fontsize=\small]{csharp}
var voice = context.UserLocale switch {
    "nl-be" => "Polly.Ruben",
    "fr-fr" => "Polly.Mathieu",
    _ => "Polly.Joanna"
};
voiceResponse.Say(response.Message, voice: voice);
voiceResponse.Gather(input: new[] { Gather.InputEnum.Speech },
    action: new Uri($"/api/twilio/process-speech/{context.ConversationId}"));
\end{minted}
\caption[TwiML Response]{Generatie van TwiML response}
\end{listing}

De TwiML response bevat een \texttt{<Say>} element met de AI-tekst en een \texttt{<Gather>} voor het opvangen van de volgende spraak-input. Per taal wordt een andere Amazon Polly-stem geselecteerd.

\section{Gespreksopname en Transcriptie}

Alle gesprekken worden opgenomen voor kwaliteitscontrole~\autocite{TwilioRecording2024}. De opname wordt gestart bij het begin van het gesprek:

\begin{listing}
\begin{minted}[fontsize=\small]{csharp}
voiceResponse.Record(
    recordingStatusCallback: new Uri("/api/twilio/recording-callback"),
    recordingChannels: "dual", trim: "trim-silence");
\end{minted}
\caption[Recording]{Configuratie van gespreksopname}
\end{listing}

De \texttt{<Record>} instructie neemt het gesprek op in dual-channel formaat (patiënt en AI apart). Na afloop wordt via een callback de opname en transcriptie opgeslagen in de SQL database.

\section{Error Handling}

Robuuste foutafhandeling is essentieel voor een betrouwbaar systeem:

\begin{listing}
\begin{minted}[fontsize=\small]{csharp}
try {
    using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(14));
    var response = await _openAiService.ProcessUserInputAsync(
        conversationId, speechResult, cts.Token);
    return GenerateTwimlResponse(response);
}
catch (OperationCanceledException) {
    return GenerateFallbackResponse("Kunt u dat herhalen?");
}
\end{minted}
\caption[Error Handling]{Timeout-afhandeling}
\end{listing}

Omdat Twilio maximaal 15 seconden wacht op een response, wordt een interne timeout van 14 seconden ingesteld. Bij een timeout krijgt de patiënt een fallback-bericht zodat het gesprek niet wordt afgebroken.

\section{Deployment}

Het systeem wordt gehost op Azure:
\begin{itemize}
    \item \textbf{Azure App Service}: Hosting ASP.NET Core applicatie
    \item \textbf{Azure Key Vault}: API keys (Twilio, OpenAI)~\autocite{AzureKeyVault2024}
    \item \textbf{SQL Database}: Opslag van gespreksopnames en transcripties
\end{itemize}

Deployment via GitHub Actions~\autocite{GitHubActions2024} naar productie bij elke push naar main.
